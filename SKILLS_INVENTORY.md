# Skills Inventory
Generated: 2025-12-23T08:55:25.079341+00:00

## algorithmic-art
**Directory**: `algorithmic-art`
**Description**: Creating algorithmic art using p5.js with seeded randomness and interactive parameter exploration. Use this when users request creating art using code, generative art, algorithmic art, flow fields, or particle systems. Create original algorithmic art rather than copying existing artists' work to avoid copyright violations.
**License**: Yes
**Instructions**: 3 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description]
This skill enables the creation of algorithmic art using p5.js. It follows a two-step process: first defining an "Algorithmic Philosophy" (a manifesto of the aesthetic movement), and then expressing that philosophy through code (HTML/JS). It emphasizes seeded randomness, emergent behavior, and computational beauty.

2. [requirements]
- Ability to generate Markdown (.md) for the philosophy.
- Ability to generate HTML and JavaScript (.js) for the p5.js sketch.
- p5.js library (usually loaded via CDN in the generated HTML).

3. [Cautions]
- Do not copy existing artists' work; focus on original algorithmic concepts.
- Ensure the generated HTML correctly references the p5.js library.
- The philosophy step is critical; do not skip it to just write code.
- The code should be 90% algorithmic generation and 10% parameters.

4. [Definitions]
- **Algorithmic Philosophy**: A written manifesto defining the aesthetic movement, rules, and behaviors of the art to be created.
- **p5.js**: A JavaScript library for creative coding.
- **Seeded Randomness**: Using a fixed seed to ensure reproducible but random-looking results.

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
To use this skill:
1. **Phase 1**: Generate an Algorithmic Philosophy based on user input. Output this as a Markdown file.
   - Name the movement.
   - Articulate the philosophy (form, process, behavior).
   - Emphasize craftsmanship.
2. **Phase 2**: Implement the philosophy in p5.js.
   - Create an HTML file that loads p5.js.
   - Create a JS file with the sketch code.
   - Ensure the code reflects the philosophy defined in Phase 1.

**Helper Script**:
You can use `python skills/algorithmic-art/scripts/scaffold_art.py --name "ProjectName"` to create the folder structure and empty files in the OUTBOX.

```

---

## artifacts-builder
**Directory**: `artifacts-builder`
**Description**: Suite of tools for creating elaborate, multi-component claude.ai HTML artifacts using modern frontend web technologies (React, Tailwind CSS, shadcn/ui). Use for complex artifacts requiring state management, routing, or shadcn/ui components - not for simple single-file HTML/JSX artifacts.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# Artifacts Builder

## Description
This skill is a specialized suite for building complex, interactive HTML artifacts using React 18, TypeScript, Tailwind CSS, and shadcn/ui components. Unlike standard single-file HTML generation, this builder supports a full modern frontend development workflow including state management, component modularity, and sophisticated UI elements. It automates the initialization of a configured project structure and handles the bundling of the entire application into a single self-contained `bundle.html` file that can be rendered directly within the Claude interface.

## Requirements
- Bash shell environment (for executing scripts).
- Node.js (v18+) and npm/yarn/pnpm.
- `scripts/init-artifact.sh`: Initializes the React project with dependencies.
- `scripts/bundle-artifact.sh`: Bundles the project into a single HTML file.
- `scripts/shadcn-components.tar.gz`: Pre-packaged UI components.

## Cautions
- **Do not** use this for simple, static HTML pages; it is overkill.
- Ensure all dependencies are correctly installed during the initialization phase.
- The bundling process inlines all assets; large assets (images, media) will significantly increase the artifact size.
- Avoid "AI slop" design patterns (excessive gradients, generic rounded corners, Inter font).
- The output must be a single HTML file (`bundle.html`).

## Definitions
- **Artifact**: A self-contained, interactive HTML file generated by the model.
- **shadcn/ui**: A collection of re-usable components built with Radix UI and Tailwind CSS.
- **Bundling**: The process of combining multiple code files (JS, CSS, HTML) into a single file.
- **Parcel**: The web application bundler used to package the artifact.

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Initialize**: Run `bash skills/artifacts-builder/scripts/init-artifact.sh <project-name>` to create the project structure.
2.  **Develop**: Edit the files in `<project-name>/src` to implement the desired functionality. Use React components and Tailwind CSS.
3.  **Bundle**: Run `bash skills/artifacts-builder/scripts/bundle-artifact.sh` from within the project directory (or pointing to it) to generate the `bundle.html`.
4.  **Present**: Output the content of `bundle.html` or provide it as a download.

Note: The scripts handle dependency installation and configuration automatically.

```

---

## brand-guidelines
**Directory**: `brand-guidelines`
**Description**: Applies Anthropic's official brand colors and typography to any sort of artifact that may benefit from having Anthropic's look-and-feel. Use it when brand colors or style guidelines, visual formatting, or company design standards apply.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# Brand Guidelines

## Description
This skill serves as a reference guide for applying Anthropic's official brand identity to generated artifacts. It defines specific color hex codes (Dark, Light, Mid Gray, Light Gray) and accent colors (Orange, Blue, Green), as well as typography standards (Poppins for headings, Lora for body). This skill does not contain executable scripts but provides the necessary constants and style rules that a model should strictly adhere to when creating designs, documents, or UI elements that require Anthropic branding.

## Requirements
- None (Reference only).
- Access to the color codes and font names defined in `SKILL.md`.

## Cautions
- Do not approximate colors; use the exact hex codes provided.
- If Poppins/Lora are not available in the target environment (e.g., web safe fonts), use the specified fallbacks (Arial for headings, Georgia for body).
- Ensure high contrast between text and background (e.g., Dark text on Light background).

## Definitions
- **Hex Code**: A six-digit alphanumeric code used to represent colors in HTML/CSS.
- **Poppins**: Geometric sans-serif typeface used for headings.
- **Lora**: Contemporary serif typeface used for body text.

## Log
(No run logs - this is a documentation skill with no scripts to execute.)

## Model Readme
Use the values defined in `SKILL.md` when generating content:
- **Primary Text**: #141413
- **Background**: #faf9f5
- **Accents**: #d97757 (Orange), #6a9bcc (Blue), #788c5d (Green).
- **Fonts**: `font-family: 'Poppins', Arial, sans-serif;` for headings; `font-family: 'Lora', Georgia, serif;` for body.

Apply these styles to HTML/CSS artifacts, SVG generation, or when writing Python code that generates visualizations (e.g., matplotlib, p5.js).


```

---

## canvas-design
**Directory**: `canvas-design`
**Description**: Create beautiful visual art in .png and .pdf documents using design philosophy. You should use this skill when the user asks to create a poster, piece of art, design, or other static piece. Create original visual designs, never copying existing artists' work to avoid copyright violations.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# Canvas Design

## Description
This skill provides a creative framework for generating high-quality visual art and design documents (.png, .pdf). It operates in two phases: first, by defining a unique "Design Philosophy" (a written aesthetic manifesto), and second, by writing and executing Python code to visually express that philosophy on a digital canvas. It emphasizes original, museum-quality abstract art, minimal text, and sophisticated composition, avoiding "AI slop" or generic templates. It allows the model to act as a high-end graphic designer using code as the medium.

## Requirements
- Python environment with image generation libraries (e.g., `PIL`/`Pillow`, `cairo`, `matplotlib`, or `reportlab`).
- Access to `./canvas-fonts/` for custom typography (if available, otherwise use system fonts).
- Ability to write and execute Python scripts to save .png or .pdf files.

## Cautions
- **Copyright**: Create original designs; do not copy existing artists.
- **Text**: Keep text minimal and visual-first. Ensure no overlaps or truncation.
- **Craftsmanship**: The code should generate high-resolution, polished outputs.
- **Fonts**: Use the provided fonts in `canvas-fonts` if possible to ensure distinctiveness.

## Definitions
- **Design Philosophy**: A 4-6 paragraph Markdown document defining the aesthetic movement, rules, and behaviors of the art.
- **Canvas**: The digital drawing surface (e.g., a PIL Image object or PDF page).
- **Visual Expression**: The translation of abstract philosophical concepts into concrete visual elements (shapes, colors, lines).

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Phase 1: Philosophy**: Generate a Markdown file defining the "Design Philosophy". Name the movement (e.g., "Brutalist Joy") and describe its visual rules (space, form, color).
2.  **Phase 2: Execution**: Write a Python script to generate the artwork based on the philosophy.
    -   Use libraries like `PIL`, `cairo`, or `reportlab`.
    -   Implement the visual rules programmatically (e.g., loops for patterns, specific color palettes).
    -   Save the output as a high-quality .png or .pdf.
3.  **Refine**: If the user requests changes, refine the code to enhance the "craftsmanship" without adding unnecessary clutter.

```

---

## declaration-builder
**Directory**: `declaration-builder`
**Description**: "This is a piece of a larger Complete pro se litigation toolkit. This skill Creates declarations with proper structure (2 matching factual actions linking facts to elements; and then to the opposing parties. This applies multi level  rule based that will take a simple routine based variables such as the declaration and adds independant sub class with specific rules to the development of the document. Here we have the Declaration-Builder, and and building away... how ever the begining generic placeholder only tells us the basics, not what type, LR, about what... and then we get into specifics for example here jurisdiction. Every Jurisdiction has its own set of specific rules, formats, procedures, and this will change the coverpage, the  and while we  can make the changes manually to the documents, here we are going to bridge the gap, the ninth cir Juristiction-specific formatting were going to tweak via XML... and make it perfect every time."
**License**: Yes
**Instructions**: 6 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
```markdown
1. [Description]
This skill is a PURE PYTHON XML-BASED DOCX GENERATOR that creates legal declarations using direct XML manipulation and zipfile packing. NO subprocess calls. Implements the "2+2+1" declaration structure (2 circumstances + 2 elements + 1 party link per fact). Supports jurisdiction-specific formatting rules (Ninth, First, DC circuits). Builds complete DOCX files from scratch by generating document.xml, styles.xml, and package files, then zipping into .docx format. This is the clean, self-contained approach.

2. [requirements]
- Python 3.x standard library only (os, io, zipfile, datetime, typing, dataclasses, xml.sax.saxutils)
- NO external dependencies (no python-docx, no subprocesses)
- Jurisdiction config database built-in (JURISDICTIONS dict)
- XML templates for document structure, styles, content types, relationships
- DeclarationFact dataclass for 2+2+1 fact structure

3. [Cautions]
- XML must be well-formed or Word will reject the file
- Margins, font sizes, line spacing use Word's measurement units (twips, half-points, twentieths of a point)
- Jurisdiction rules are hardcoded in JURISDICTIONS dict - must update for new circuits
- No validation of fact structure - assumes DeclarationFact objects are properly formed
- Generated files have no edit history or metadata beyond basic document properties

4. [Definitions]
- **2+2+1 Structure**: Declaration format with 2 circumstances (time/place + parties), 2 elements (primary + supporting), 1 party link
- **Twips**: 1/1440th of an inch (Word's base measurement unit for margins)
- **Half-points**: Font size unit where 28 = 14pt
- **XML Manipulation**: Directly editing document.xml instead of using library like python-docx
- **Zipfile Packing**: Creating .docx by zipping XML files (DOCX is a ZIP container)
- **DeclarationFact**: Dataclass representing single fact with title, circumstances, elements, party links, evidence UIDs

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
This is the GOLD STANDARD approach for document generation:
- No external dependencies beyond Python stdlib
- No subprocess calls
- Direct XML control = perfect formatting preservation
- Jurisdiction-aware via JURISDICTIONS config
- Uses proper legal structure (2+2+1 facts)

Key components:
- document_builder.py: Main XML generator (633 lines)
- DOCUMENT_XML_TEMPLATE: Base document structure
- STYLES_XML: Formatting rules template
- COVER_NINTH_XML: Ninth Circuit cover page template
- JURISDICTIONS: Circuit-specific configs (font, margins, rules)

This should be the model for refactoring other skills.

```

```

---

## INPUT
**Directory**: `INPUT`
**Description**: 
**License**: No
**Instructions**: 0 files

---

## internal-comms
**Directory**: `internal-comms`
**Description**: A set of resources to help me write all kinds of internal communications, using the formats that my company likes to use. Claude should use this skill whenever asked to write some sort of internal communications (status reports, leadership updates, 3P updates, company newsletters, FAQs, incident reports, project updates, etc.).
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# Internal Comms

## Description
This skill provides structured templates and guidelines for drafting standardized internal organizational communications. It ensures consistency, clarity, and professionalism across various communication types such as 3P updates (Progress, Plans, Problems), company newsletters, FAQs, and general status reports. By leveraging pre-defined Markdown templates, it helps the model generate content that aligns with corporate best practices and specific formatting requirements.

## Requirements
- Access to the `examples/` directory containing the guideline files (`3p-updates.md`, `company-newsletter.md`, etc.).
- Context provided by the user regarding the specific content (e.g., project details, team updates).

## Cautions
- **Tone**: Maintain a professional, objective tone suitable for internal business contexts.
- **Accuracy**: Ensure all generated content accurately reflects the user's input; do not invent metrics or status updates.
- **Formatting**: Strictly follow the structure defined in the selected guideline file (e.g., headers, bullet points).

## Definitions
- **3P Update**: A reporting format focusing on Progress (what was done), Plans (what will be done), and Problems (blockers).
- **Internal Comms**: Communications intended for an audience within the organization, not external clients or public.

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Identify Type**: Determine the type of communication requested (3P, Newsletter, FAQ, or General).
2.  **Read Template**: Read the corresponding file in `skills/internal-comms/examples/`:
    -   `3p-updates.md`
    -   `company-newsletter.md`
    -   `faq-answers.md`
    -   `general-comms.md`
3.  **Generate**: Draft the communication following the structure and instructions found in the template file.
4.  **Review**: Ensure the tone is appropriate and all sections are complete.

```

---

## macros
**Directory**: `macros`
**Description**: 
**License**: No
**Instructions**: 0 files

---

## mcp-builder
**Directory**: `mcp-builder`
**Description**: Guide for creating high-quality MCP (Model Context Protocol) servers that enable LLMs to interact with external services through well-designed tools. Use when building MCP servers to integrate external APIs or services, whether in Python (FastMCP) or Node/TypeScript (MCP SDK).
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# MCP Builder

## Description
This skill is a comprehensive guide and toolkit for developing high-quality Model Context Protocol (MCP) servers. It provides a structured workflow—from research and planning to implementation and evaluation—ensuring that the resulting servers are robust, agent-friendly, and compliant with MCP standards. It supports both Python (FastMCP) and Node/TypeScript SDKs, offering best practices, reference materials, and evaluation strategies to build tools that LLMs can effectively use to interact with external systems.

## Requirements
- **Core**: Knowledge of the MCP Protocol (available via WebFetch or provided references).
- **Python Dev**: Python 3.x, `mcp` SDK, `pydantic`.
- **Node Dev**: Node.js, TypeScript, `@modelcontextprotocol/sdk`, `zod`.
- **Reference Files**: Access to `reference/` directory (`mcp_best_practices.md`, `python_mcp_server.md`, etc.).

## Cautions
- **Blocking Processes**: MCP servers are long-running; do not run them directly in the main process during development (use tmux or timeouts).
- **Context Windows**: Optimize tool outputs for limited context windows; use concise formats.
- **Error Handling**: Ensure error messages are actionable for the agent, not just stack traces.
- **Security**: Validate all inputs using strict schemas (Pydantic/Zod).

## Definitions
- **MCP**: Model Context Protocol, a standard for connecting AI models to external data and tools.
- **Server**: An application that provides a list of tools/resources to an MCP client (the LLM).
- **Transport**: The communication channel (stdio, SSE) used by the protocol.
- **FastMCP**: A high-level Python framework for building MCP servers quickly.

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill, follow the 4-Phase Workflow defined in `SKILL.md`:
1.  **Research**: Plan the tools based on agent workflows, not just API endpoints. Study the `reference/mcp_best_practices.md`.
2.  **Implementation**:
    -   For **Python**, refer to `reference/python_mcp_server.md`. Use the `mcp` package and Pydantic models.
    -   For **TypeScript**, refer to `reference/node_mcp_server.md`. Use `zod` for schemas.
3.  **Refine**: Ensure code quality, DRY principles, and proper error handling.
4.  **Evaluate**: Create an evaluation suite using `reference/evaluation.md` to verify the server's effectiveness with realistic queries.

```

---

## ninth-circuit-brief-body
**Directory**: `ninth-circuit-brief-body`
**Description**: "Generate Ninth Circuit appellate brief body sections. This skill should be used when assembling brief sections (jurisdictional statement, issues presented, statement of case, argument, etc.) from evidence and facts. Each section is built separately and assembled into a complete brief. NO REWORDING of source material."
**License**: Yes
**Instructions**: 4 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
```markdown
1. [Description]
This is a REFERENCE-ONLY skill containing documentation, templates, and rules for Ninth Circuit brief body sections. NO EXECUTABLE SCRIPTS. Contains FRAP rules reference (frap_rules.md), data structure mapping guide (data-map.md), motion template guidelines (motion-template-guide.md), and example brief shell (Shell_Brief.pdf). Used by models to understand brief structure, citation requirements, and formatting standards when generating brief content with other skills.

2. [requirements]
- None (read-only reference files)
- PDF reader for Shell_Brief.pdf
- Markdown viewer for .md files

3. [Cautions]
- This skill does NOT generate documents - it only provides reference material
- FRAP rules may change - verify current rules before filing
- Shell_Brief.pdf is an example only, not a template for direct use
- Data mapping guide assumes specific JSON schema structure

4. [Definitions]
- **FRAP**: Federal Rules of Appellate Procedure governing appellate brief format and content
- **Shell Brief**: Example document showing section structure without actual content
- **Data Map**: Guide for mapping structured data (JSON) to brief sections
- **Reference Skill**: Documentation-only skill with no executable components

5. [log]
(No run logs - this is a documentation skill with no scripts to execute.)

6. [model_readme]
This skill provides supporting documentation for brief generation:
- **6-references/frap_rules.md**: Federal Rules of Appellate Procedure excerpts
- **6-references/data-map.md**: JSON structure mapping for brief data
- **6-references/motion-template-guide.md**: Guidelines for motion formatting
- **6-references/Shell_Brief.pdf**: Example brief structure

Use these references when generating brief content with ninth-circuit-opening-brief or other brief-generation skills. NO SCRIPTS TO RUN.

```

```

---

## ninth-circuit-cover
**Directory**: `ninth-circuit-cover`
**Description**: "Generate Ninth Circuit Court of Appeals cover pages. This skill should be used when creating cover pages for appellate briefs, motions, or other filings in the Ninth Circuit. Requires case number, filing type, and judge name."
**License**: Yes
**Instructions**: 6 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description]
This skill generates a Ninth Circuit Court of Appeals compliant cover page. It uses a Python script to populate a DOCX template with case-specific information such as the case number, filing title, and judge's name. It is designed to ensure formatting compliance for appellate briefs and motions.

2. [requirements]
- Python 3.x
- `python-docx` library
- A valid DOCX template (internal to the script or provided path)
- Access to `d:\Nineth Circuit\CLAUDE_COPILOT HLP\NINTH CIR5\COVER_GENERATOR_COMPLETE\generate_cover.py` (Note: The script location is external to the skill folder in the current configuration, see SKILL.md).

3. [Cautions]
- Ensure the Case Number is in the correct format (e.g., 25-6461).
- The script path is hardcoded in the SKILL.md examples; verify the path exists before running.
- The output directory `COVER_GENERATOR_COMPLETE/output/` must exist or be writable.
- Verify the judge's name spelling as it appears on the District Court docket.

4. [Definitions]
- **Case Number**: The appellate case number assigned by the Ninth Circuit (not the District Court number).
- **Filing Name**: The exact title of the document being filed (e.g., "APPELLANT'S OPENING BRIEF").
- **Judge Name**: The name of the District Court judge whose decision is being appealed.

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
To use this skill, execute the python script `generate_cover.py` with the required arguments.
Command format:
`python "d:\Nineth Circuit\CLAUDE_COPILOT HLP\NINTH CIR5\COVER_GENERATOR_COMPLETE\generate_cover.py" --case "[CASE_NUMBER]" --filing "[FILING_NAME]" --judge "[JUDGE_NAME]"`

Example:
`python "d:\Nineth Circuit\CLAUDE_COPILOT HLP\NINTH CIR5\COVER_GENERATOR_COMPLETE\generate_cover.py" --case "25-6461" --filing "APPELLANT'S OPENING BRIEF" --judge "Stacy Beckerman"`

The output will be a DOCX file in the output directory. Check the terminal output for the exact path.

```

---

## ninth-circuit-declaration
**Directory**: `ninth-circuit-declaration`
**Description**: 
**License**: Yes
**Instructions**: 5 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
```markdown
1. [Description]
This skill is a BUILD ORCHESTRATOR that creates complete Ninth Circuit declarations by calling multiple external scripts in sequence: (1) regenerates template with strict formatting from styles.json, (2) generates cover page via COVER_GENERATOR, (3) populates declaration body via RENDER_SCRIPT with placeholder replacement, (4) merges cover + body into final DOCX. Takes a single JSON config file and outputs a 2-page formatted declaration. This is a pipeline coordinator, not a document builder itself.

2. [requirements]
- Python 3.x
- External scripts: COVER_GENERATOR (PIMP-SMACK-APP/_archive/COVER_GENERATOR_COMPLETE/generate_cover.py), RENDER_SCRIPT (universal-motion-brief/scripts/render_docx.py), MERGE_SCRIPT (scripts/merge_docs.py)
- generator.py in 4-scripts folder for template regeneration
- styles.json in skill root (3-styles.json)
- declaration_template.docx in 5-templates folder
- Valid JSON config file (supports both simple legacy format and advanced metadata format)

3. [Cautions]
- All external script paths are hardcoded - they MUST exist or build fails
- Uses subprocess.run() to call external scripts (violates no-subprocess rule)
- Temporary files created in .outbox are deleted after merge
- Config file must have either 'metadata' key (advanced) or 'case_metadata' key (legacy)
- Output filename enforced as YYYY-MM-DD_ToolName-Filename.docx format

4. [Definitions]
- **Build Orchestrator**: Script that coordinates multiple other scripts rather than doing work itself
- **Strict Styles**: Formatting rules from legal_styles_strict.json enforcing court compliance
- **Simple Config**: Legacy format with case_metadata, document_content, formatting keys
- **Advanced Config**: New format with metadata, placeholders.standard, placeholders.runtime, styles keys
- **Merge**: Combining cover page and body into single DOCX file

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
Run with: `python 4-scripts/build.py [config_file]`
Default config: filing_config.json in current directory

The orchestrator executes this pipeline:
1. generator.py regenerates template with styles from 3-styles.json
2. COVER_GENERATOR creates temp_cover.docx from case metadata
3. RENDER_SCRIPT populates temp_body.docx from document_content placeholders
4. MERGE_SCRIPT combines into final output

WARNING: This uses subprocesses and external dependencies. Does NOT follow self-contained skill pattern. Candidate for refactoring.

```

```

---

## ninth-circuit-opening-brief
**Directory**: `ninth-circuit-opening-brief`
**Description**: Assemble FRAP 28-compliant Ninth Circuit opening briefs by copying user-provided sections into a fixed template/ordering. Never rewrite substantive text.
**License**: Yes
**Instructions**: 9 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
```markdown
1. [Description]
This skill assembles complete Ninth Circuit opening briefs by processing tagged section files (=== SECTION NAME === format) and combining them in proper FRAP 28 order. Three-script pipeline: (1) 6-ingest_brief_sections.py parses tagged text into sections.json, (2) 5-copy_plain_sections.py updates sections from tagged files with backup option, (3) 4-assemble_opening_brief.py builds final brief from JSON data with TOC/TOA generation, word count validation, and compliance checking. CRITICAL: NO TEXT GENERATION - scripts only copy/assemble existing text verbatim.

2. [requirements]
- Python 3.x standard library (json, argparse, pathlib, re, datetime, collections)
- Brief data files in 9-brief_data/ (sections.json, authorities.json)
- Templates in 8-templates/ (if needed for formatting)
- References in 7-references/ (formatting standards, local rules)
- Tagged input files with === SECTION NAME === markers

3. [Cautions]
- Scripts are READ-ONLY copiers - they NEVER reword or generate text
- Must run scripts in order: 6 (ingest), then 5 (copy), then 4 (assemble)
- FRAP 32 word limit default 14000 words (excludes cover, TOC, TOA, certificates)
- Tagged section names must match SECTION_MAP exactly (case-sensitive)
- sections.json case_info is never touched by ingest/copy scripts
- Use --backup flag before modifying existing sections.json

4. [Definitions]
- **Tagged Sections**: Text format using === HEADING === to mark section boundaries
- **Verbatim Copy**: Exact text transfer with no rewording, styling, or generation
- **FRAP 28**: Federal Rule of Appellate Procedure 28 defining brief structure and order
- **TOC**: Table of Contents (auto-generated from headings)
- **TOA**: Table of Authorities (auto-generated from citations in authorities.json)
- **SECTION_MAP**: Dictionary mapping tag names to JSON section keys

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
Three-script workflow:

**6-ingest_brief_sections.py** - Parse tagged text into sections.json
```
python 6-ingest_brief_sections.py --input pasted_brief.txt --backup
```

**5-copy_plain_sections.py** - Update specific sections from tagged file
```
python 5-copy_plain_sections.py --input updated_sections.txt --backup
```

**4-assemble_opening_brief.py** - Build final brief
```
python 4-assemble_opening_brief.py --all --case-no 25-XXXXX
python 4-assemble_opening_brief.py --validate  # Check structure
python 4-assemble_opening_brief.py --word-count  # Verify limits
```

Data structure: 9-brief_data/sections.json contains case_info + sections
AUTO_GENERATED sections: cover_page, TOC, TOA, certificates (built by assembler)

```

```

---

## pimp-formatting-skills
**Directory**: `PIMP-SMACK-APP`
**Description**: Legal Document Formatter for Pro Se Litigants. Uses taxonomy files to format ANY legal document with correct structure and jurisdiction-specific styling. READ PimpJuice_instructions/MODEL_INSTRUCTIONS.md FIRST.
**License**: Yes
**Instructions**: 3 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description] {must explain the purpose of the skill and what it does, DO NOT MAKE A DESCRIPTION THAT DOES NOT EXPLAIN WITH PARTICULARITY WHAT THE SKILL DOES! GENERALLY 100 < Tokens/words }
2. [requirements] (dependencies)
3. [Cautions] (things that might potentially be an issue)
4. [Definitions] (this is things that are not common not everything)
5. [log] (mark directly on this page where this was ran so the model can see the output example if available)
6. [model_readme] (this is where the model will include any notes regarding the running of the script for the models to have a proper understanding of how they are built)

```

---

## skill-creator
**Directory**: `skill-creator`
**Description**: Guide for creating effective skills. This skill should be used when users want to create a new skill (or update an existing skill) that extends Claude's capabilities with specialized knowledge, workflows, or tool integrations.
**License**: Yes
**Instructions**: 3 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description]
This skill provides the canonical guide and tools for creating new skills or updating existing ones. It defines the required structure (SKILL.md, instructions folder, scripts), metadata standards, and best practices for extending the agent's capabilities. It includes scripts to validate the skill structure.

2. [requirements]
- Python 3.x (for validation scripts)
- A text editor
- Understanding of the skill structure defined in `SKILL.md`.

3. [Cautions]
- Always run `scripts/build_index.py` (from the skills root) after creating or modifying a skill to ensure it is indexed correctly.
- Do not deviate from the folder structure: `skills/[skill-name]/SKILL.md` and `skills/[skill-name]/[skill-name]_instructions/`.
- Ensure `SKILL.md` has valid YAML frontmatter.

4. [Definitions]
- **Skill**: A modular package of knowledge and tools.
- **Frontmatter**: YAML metadata at the top of `SKILL.md` (name, description).
- **Instructions Folder**: A directory named `[skill-name]_instructions` containing numbered markdown files.

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
When creating a new skill:
1. Create a new directory in `skills/` with a kebab-case name.
2. Create `SKILL.md` with the required frontmatter.
3. Create the `[skill-name]_instructions` directory.
4. Add `1-models_readme.md` and populate it with this schema.
5. Add any necessary scripts in a `scripts/` subdirectory.
6. Run `python skills/skill-creator/scripts/quick_validate.py [path_to_new_skill]` to check your work.
7. Run `python skills/scripts/build_index.py` to update the global index.

```

---

## slack-gif-creator
**Directory**: `slack-gif-creator`
**Description**: Toolkit for creating animated GIFs optimized for Slack, with validators for size constraints and composable animation primitives. This skill applies when users request animated GIFs or emoji animations for Slack from descriptions like "make me a GIF for Slack of X doing Y".
**License**: Yes
**Instructions**: 3 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description]
This skill provides a toolkit for creating animated GIFs optimized for Slack. It includes validators for Slack's strict size/dimension constraints and composable primitives for creating animations (shake, bounce, etc.). It is useful for creating custom emoji or reaction GIFs.

2. [requirements]
- Python environment with image processing capabilities (likely PIL/Pillow).
- Access to the validator scripts and animation primitives defined in the skill.
- Source images or text to animate.

3. [Cautions]
- **Strict Limits**: Slack Emoji GIFs must be < 64KB. This is very small.
- **Dimensions**: 128x128 for emojis, 480x480 for message GIFs.
- **Colors**: Limit palette to 32-48 colors for emojis to save space.

4. [Definitions]
- **Emoji GIF**: A small, square animated image used as a custom emoji.
- **Message GIF**: A larger animated image used in chat messages.
- **Validator**: A script that checks if the file meets Slack's technical requirements.

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
To create a Slack GIF:
1. **Determine Type**: Emoji (<64KB) or Message (~2MB).
2. **Create**: Use animation primitives (code) to generate frames.
3. **Optimize**: Reduce colors, frames, and dimensions.
4. **Validate**: Run the validator script to ensure it meets Slack's limits.
5. **Iterate**: If validation fails, reduce quality/length and try again.

**Helper Script**:
Use `python skills/slack-gif-creator/scripts/create_gif.py --create-sample "output.gif"` to generate a sample or `--validate "output.gif"` to check compliance.

```

---

## template-skill
**Directory**: `template-skill`
**Description**: Replace with description of the skill and when Claude should use it.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# [Skill Name]

## Description
[Describe the skill's purpose, what it does, and the specific problems it solves. This section helps the model understand the high-level intent and functionality. Keep it concise but specific (approx. 100 words).]

## Requirements
- [List specific dependencies, tools, or access rights required.]
- [E.g., Python libraries, specific file paths, or external API keys.]

## Cautions
- [List potential pitfalls, edge cases, or strict constraints.]
- [E.g., "Do not overwrite existing files without backup", "Strictly follow JSON schema".]

## Definitions
- **[Term 1]**: [Definition of a domain-specific term used in this skill.]
- **[Term 2]**: [Definition.]

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Step 1**: [Action to take]
2.  **Step 2**: [Action to take]
3.  **Step 3**: [Action to take]
    -   [Sub-detail or command example]

[Include any relevant scripts or commands the model should run.]

```

---

## theme-factory
**Directory**: `theme-factory`
**Description**: Toolkit for styling artifacts with a theme. These artifacts can be slides, docs, reportings, HTML landing pages, etc. There are 10 pre-set themes with colors/fonts that you can apply to any artifact that has been creating, or can generate a new theme on-the-fly.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# Theme Factory

## Description
This skill acts as a design system manager, providing 10 pre-defined professional visual themes (color palettes and font pairings) that can be applied to various artifacts (slides, documents, HTML pages). It also supports on-the-fly generation of custom themes based on user preferences. Its primary purpose is to ensure visual consistency and aesthetic quality in generated content without requiring the user to be a designer. It bridges the gap between raw content and polished presentation.

## Requirements
- Access to the `themes/` directory containing the 10 pre-set Markdown theme files.
- Access to `theme-showcase.pdf` for visual reference (if supported by the environment).
- Ability to read hex codes and font names from the theme files and apply them to the target artifact (e.g., CSS for HTML, XML for DOCX/PPTX).

## Cautions
- **Consistency**: When applying a theme, ensure all elements (headings, body, backgrounds, accents) use the specified values.
- **Contrast**: Ensure text remains readable against background colors.
- **Fallback**: If a specific font is not available in the target format/environment, select a close alternative (serif vs. sans-serif).

## Definitions
- **Theme**: A cohesive set of design decisions including a color palette (primary, secondary, accent, background) and typography (heading font, body font).
- **Artifact**: The output file or content being styled (e.g., a PowerPoint deck, a React component, a PDF).

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Showcase**: Offer the user a choice of themes. If possible, reference `theme-showcase.pdf` or list the names (Ocean Depths, Sunset Boulevard, etc.).
2.  **Select**: Once a theme is chosen, read the corresponding file in `skills/theme-factory/themes/` (e.g., `ocean-depths.md`).
3.  **Apply**: Extract the hex codes and font names.
    -   For **HTML/CSS**: Create a `:root` variable set or Tailwind config.
    -   For **Python/PPTX**: Use the hex codes to set RGB colors.
4.  **Custom**: If the user wants a custom theme, generate a new palette and font pairing that matches their description, following the structure of the existing theme files.

```

---

## universal-motion-brief
**Directory**: `universal-motion-brief`
**Description**: Build motions and appellate briefs from user-supplied DOCX templates using JSON or XML data. Preserves user formatting; requires template with {{placeholders}}.
**License**: Yes
**Instructions**: 6 files

### Metadata Sections Found
- [Description]: ✅
- [requirements]: ✅
- [Cautions]: ✅
- [Definitions]: ✅
- [log]: ✅
- [model_readme]: ✅

### Model Readme Content
```markdown
1. [Description]
This skill builds motions and appellate briefs by merging structured data (JSON) into a user-supplied DOCX template. It preserves the original template's formatting, styles, and footnotes, making it ideal for generating documents that require strict adherence to a specific layout or style guide without the risk of generative AI hallucinating formatting.

2. [requirements]
- Python 3.x
- `python-docx` library
- A `.docx` template file with `{{PLACEHOLDERS}}`.
- A `.json` data file containing the values for the placeholders.

3. [Cautions]
- Placeholders must match exactly (case-sensitive).
- Do not place placeholders inside footnotes if you need to preserve them (the script may not process them correctly or might break the footnote reference).
- Ensure the JSON structure matches the expected placeholders.
- The script does not re-flow text; it only replaces tokens.

4. [Definitions]
- **Template**: A DOCX file containing static text and `{{TOKEN}}` placeholders.
- **Mapping**: An optional JSON file that maps keys in your data to the tokens in the template (e.g., `{"case_no": "CASE_NUMBER"}`).
- **Render**: The process of replacing placeholders with actual data.

5. [log]
(No run logs available yet. This section will be populated by the system upon successful execution.)

6. [model_readme]
Use the `scripts/render_docx.py` script to generate the document.

Command format:
`python skills/universal-motion-brief/scripts/render_docx.py --template "[PATH_TO_TEMPLATE]" --data "[PATH_TO_DATA]" --output "[PATH_TO_OUTPUT]"`

Options:
- `--mapping [PATH]`: Use if your data keys don't match template tokens.
- `--strict`: Fail if any placeholder is left unfilled.

Example:
`python skills/universal-motion-brief/scripts/render_docx.py --template "templates/motion.docx" --data "data/motion_data.json" --output "OUTBOX/motion.docx"`

```

---

## webapp-testing
**Directory**: `webapp-testing`
**Description**: Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality, debugging UI behavior, capturing browser screenshots, and viewing browser logs.
**License**: Yes
**Instructions**: 3 files

### Model Readme Content
```markdown
# WebApp Testing

## Description
This skill provides a toolkit and workflow for testing local web applications using Python and Playwright. It is designed to handle both static HTML files and dynamic web applications (React, Vue, etc.) that require a running server. It includes helper scripts to manage server lifecycles (starting/stopping servers automatically) and guidelines for a "Reconnaissance-Then-Action" approach: inspecting the DOM state before attempting interactions to ensure robust, non-flaky automation.

## Requirements
- Python environment with `playwright` installed.
- Playwright browsers installed (`playwright install chromium`).
- `scripts/with_server.py`: Helper script for managing background servers.
- Application source code or static HTML to test.

## Cautions
- **Headless Mode**: Always run Playwright in headless mode (`headless=True`) unless specifically debugging visually.
- **Wait States**: For dynamic apps, always use `page.wait_for_load_state('networkidle')` before inspecting the DOM to avoid "element not found" errors.
- **Server Management**: Do not try to manually manage background processes with `&`; use `with_server.py` to ensure clean startup and teardown.

## Definitions
- **Playwright**: A Python library for browser automation.
- **Network Idle**: A state where there are no active network connections for at least 500ms, indicating the page has finished initial loading.
- **Selector**: A pattern used to locate elements on the page (CSS, XPath, text, role).

## Log
(No run logs available yet. This section will be populated by the system upon successful execution.)

## Model Readme
To use this skill:
1.  **Analyze**: Determine if the target is a static file or a dynamic app.
2.  **Server Setup**:
    -   If dynamic and server not running: Use `python scripts/with_server.py --server "cmd" --port XXX -- python test_script.py`.
    -   If static: Use `file:///` URLs directly.
3.  **Develop Script**: Write a Python script using `sync_playwright`.
    -   Pattern: Launch -> Page -> Goto -> **Wait** -> Inspect/Interact -> Close.
4.  **Execute**: Run the script. If using `with_server.py`, the server will start, wait for the port, run your script, and then shut down.

```

---
